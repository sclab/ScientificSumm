45 checkSucceeding(c) = return status and CharacterValue of the next character The function checkCharValue determines the CharacterValue of a character c. checkCharValue(c) = return CharacterValue of character c The function sendUpdate sends an update message (UpdateMessage) from the database to the real-time server component.
The relevant parameters for the definitions beneath, are introduced in the following list: - nextCharacterOID: OID of the character situated next to the string to be inserted - previousCharacterOID: OID of the character situated previously to the string to be inserted - characterOIDs (List): List of character which have to be inserted Thus, the insertion of characters can be defined stepwise as follows: Start a transaction.
Editor B now inserts a character into this document.
releaseLocks commitTA Send update information to the real-time server component sendUpdate(UpdatenMessage) Read update message and inform affected editors of the change Read(UpdateMessage) Allocate Editors(UpdateMessage, SessionManager) SendMessage(EditorData) 3.2 Insert Characters Example Figure 1 gives a snapshot the system, i.e.
c = character p=previous character n = next character l = list of characters The symbol c1 stands for the first character in the list l, ci stands for a character in the list l at the position i, whereas i is a value between 1 and the length of the list l, and cn stands for the last character in the list l. c1 = first character in list l ci = character at position i in list l cn = last character in list l The symbol β stands for the special character that marks the beginning of a document and ε stands for the special character that marks the end of a document.
releaseLocks = release all locks The function getPrevious returns the previous character and getNext returns the next character of a character c. getPrevious(c) = return previous character of character c getNext(c) = return next character of character c The function linkBefore links a preceding character p with a succeeding character x and the function linkAfter links a succeeding character n with a preceding character y. linkBefore(p,x) = link character p to character x linkAfter(n,y) = link character n to character y The function updateString links a character p with the first character c1 of a character list l and a character n with the last character cn of a character list l updateString(l, p, n) = linkBefore(p cl)∧ linkAfter(n, cn ) The function insertChar inserts a character c in the table Char with the fields After set to a character p and Before set to a character n. insertChar(c, p, n) = linkAfter(c,p) ∧ linkBefore(c,n) ∧ linkBefore(p,c) ∧ linkAfter(n,c) The function checkPreceding determines the previous character's CharacterValue of a character c and if the previous character's status is active.
Considering that editor A (connected to database 1 and 4) and editor B (connected to database 1 and 2) are working on the same document stored in database 1.
The insert operation is passed to application server 1, which in turns, passes it to the database 1, where an insert operation is invoked; the characters are inserted according to the algorithm discussed in the previous section.
The proposed architecture is validated on the example of a character insertion.
After the insertion, database 1 sends an update message (according to the update protocol discussed before) to real-time server component 1 (via AS 1).
3.1 Insert Characters Algorithm The symbol c stands for the object character, p stands for the previous character, n stands for the next character of a character object c and the symbol l stands for a list of character objects.
Editors are connected to one or more real-time server components and to the corresponding databases.
getPrevious(nextCharacterOID) = PrevChar(prevCharOID) ⇐ Π After ϑOID = nextCharacterOID(Char)) Acquire the lock for the character that is situated in the document before the character that follows the string which shall be inserted.
β=beginning of document ε=end of document The function startTA starts a transaction.
AllocateEditors(UpdateInformationMessage, SessionManager) = returns the affected editors The function SendMessage(EditorData) sends the editor part of the UpdateMessage to the editors SendMessage(EditorData) In TeNDaX, the Insert Algorithm is implemented in the class method InsertChars of the class Char which is depicted in Figure 2.
startTA Select the character that is situated before the character that follows the string to be inserted.
The character insertion is based on the TeNDaX Insert Algorithm which is formally described in the following.
RTCS 1 combines the received update information with the information in his SessionManager and sends the editor data to the affected editors, in this case to editor A and B, where the changes are immediately shown.
lock(prevCharId) At this time the list characterOIDs contains the characters c1 to cn that shall be inserted.
Each database is connected to an application server (AS) and each application server is connected to a real-time server component (RTSC).
Read(UpdateInformationMessage) The function AllocatEditors checks on the base of the UpdateMessage and the SessionManager, which editors have to be informed.
characterOIDs={ c1, …, cn } Each character of the string is inserted at the appropriate position by linking the preceding and the succeeding character to it.
checkPreceding(c) = return status and CharacterValue of the previous character The function checkSucceeding determines the next character's CharacterValue of a character c and if the next character's status is active.
sendUpdate(UpdateMessage) The function Read is used in the real-time server component to read the UpdateMessage.
checkWriteAccess(s) = check if write access for document session s is granted The function lock acquires an exclusive lock for a character c and returns 1 for a success and 0 for no success.
commitTA = commit transaction The function checkWriteAccess checks if the write access for a document session s is granted.
startTA = start transaction The function commitTA commits a transaction that was started.
For each character ci of characterOIDs: insertChar(ci, p, n) Whereas ci ∈ { c1,…, cn } Check if the preceding and succeeding characters are active or if it is the beginning or the end of the document.
lock(c) = acquire the lock for character c success : return 1, no success : return 0 The function releaseLocks releases all locks that a transaction has acquired so far.
Insert operations are the mostly used operations in a (collaborative) editing system.
updateString(characterOIDs, prevCharOID, nextCharacterOID) Release all locks and commit Transaction.
checkPreceding(prevCharOID) = IsOK(IsActive, CharacterValue) ⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) checkSucceeding(nextCharacterOID) = IsOK(IsActive, CharacterValue)⇐ Π IsActive, CharacterValue (ϑ OID = nextCharacterOID(Char)) Update characters before and after the string to be inserted.
The algorithm is simplified for this purpose.
Occurring collaboration conflicts are solved and described in [3].
of its architecture: four databases are distributed over a peer-to-peer network.
