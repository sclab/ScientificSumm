After the Spotlight device receives the ACK, at its local time T4, the time synchronization can be achieved as follows: 2 )()( 4312 TTTT Offset −+− = (11) OffsetTTT spotlightnodeglobal +== We note that Equation 11 assumes that the one trip delays are the same in both directions.
The Spotlight system uses the timestamp received from a sensor node j, to obtain the angular measures Altj and Azj for its location.
The first implementation, called μSpotlight, had a short range (10-20 meters), however its capability of generating the entire spectrum of EDFs made it very useful.
This allowed us to bypass the windowing system and more precisely estimate the time when an event is displayed by the projector, hence a higher accuracy of timestamps of events.
If the following condition is true: nei dd = where en is an event with code den, then the inferred location for node i is: nn ee yyxx == , 4.5 Time Synchronization The time synchronization in the Spotlight system consists of two parts: - Synchronization between sensor nodes: This is achieved through the Flooding Time Synchronization Protocol [18].
18 The laptop computer, through a Java GUI, controls the motion of the telescope mount, orienting it such that a full Point Scan of an area is performed, similar to the one described in Figure 3(b).
In the remaining part of this section, we describe how we implemented the three components (Event Distribution, Event Detection and Localization functions) of the Spotlight architecture, and the time synchronization protocol, a key component of our system.
An event i will be time stamped with time ti, if the reading from the photo sensor dti, fulfills the condition: itdd <Δ+max where dmax is the maximum value reported by the photo sensor before ti and Δ is a constant which ensures that the first large detection gives the timestamp of the event (i.e.
Two-way synchronization As shown in Figure 12, let"s assume that the Spotlight device sends a synchronization message (SYNC) at local time T1, the sensor node receives it at its local time T2 and acknowledges it at local time T3 (both T2 and T3 are sent back through ACK).
For each turning point i, the 3-tuple (Alti and Azi angles and the timestamp ti) is recorded.
If the reported timestamps are constrained by: 11 + << nn ee ttt , and 12 + << mm ee ttt where en and en+1 are two consecutive events on the horizontal scan and em and em+1 are two consecutive events on vertical scan, then the inferred location for node i is: 11 , ++ == mn ee yyxx The Localization Function for the Area Cover EDF has as input a timestamp set Ti={ti1, ti2, …, tin} of the n events, detected by node i.
If t1 is constrained by: 11 + << nn ee ttt where en and en+1 are two consecutive events, then the obtained location for node i is: 11 , ++ == nn ee yyxx The case for the Line Scan is treated similarly.
Figure 10. μSpotlight system implementation With this implementation of the Spotlight system, we were able to generate Point, Line and Area Scan events.
Because of the 50Hz refresh rate of our projector, there was still an uncertainty in the time stamping of the events of 20msec.
- Synchronization between the sensor nodes and the Spotlight device: We implemented this part through a two-way handshaking between the Spotlight device and one node, used as the base station.
The second implementation, the Spotlight system, had a much longer range (as far as 6500m), but it was limited in the types of EDFs that it can generate.
The Localization Function for the Point Scan EDF has as input a time sequence Ti = {t1}, as reported by node i.
It matches the timestamps created by the Event Distribution Function with those reported by the sensor nodes.
Due to the stringent timing requirements and the delay caused by the buffering in the windowing system of a PC, we used the Full-Screen Exclusive Mode API provided by Java2.
The handshaking is done fast, through a 2 byte exchange between the Spotlight device and the sensor node (the timestamps are still recorded, but not sent).
4.2 Spotlight System The second Spotlight system we built used, as the Spotlight device, diode lasers, a computerized telescope mount (Celestron CG-5GT, shown in Figure 11), and an IBM Thinkpad laptop.
In astronomy, the Altitude of a celestial object is its angular distance above or below the celestial horizon, and the Azimuth is the angular distance of an object eastwards of the meridian, along the horizon.
For the sensor nodes, we used XSM motes, mainly because of their longer communication range.
The input to the Localization Function is the time sequence Ti = {t1, t2} as reported by node i.
Using these two implementations we were able to investigate the full spectrum of Event Distribution techniques, proposed in Section 3, at a reduced one time cost (less than $1,000).
4.3 Event Detection Function D(t) The Event Detection Function aims to detect the beginning of an event and record the time when the event was observed.
Once a receiver gets the message, it follows the sender's time and performs the necessary calculations to compensate for the clock drift.
The laptop was connected, through RS232 interfaces, to the telescope mount and to one XSM600CA [7] mote, acting as a base station.
We implemented a very simple detection function based on the observed maximum value.
We explored the possibility of using and modifying the Linux kernel to expose the vertical synch (VSYNCH) interrupt, generated by the displaying device after each screen refresh, out of the kernel mode.
We had to make minor adjustments to the plastic housing, in order to expose the photo sensor to the outside.
The sender puts the time stamp into the synchronization message right before the bytes containing the time stamp are transmitted.
The function performs a simple search for the event with a timestamp closest to t1.
We recall the notation for the set of m timestamps of events generated by the Spotlight device, T"={t1", t2", …, tm"}.
The goal of this implementation was to show how the Spotlight system works in a real, outdoor environment, and show correlations with the experimental results obtained from the μSpotlight system implementation.
The two angular measures that we used were the, so called, Alt (from Altitude) and Az (from Azimuth).
To improve the performance, we separate the handshaking process from the timestamp exchanges.
In this protocol, synchronized nodes (the root node is the only synchronized node at the beginning) send time synchronization message to unsynchronized nodes.
The result indicates that this approach can significantly improve the accuracy of time synchronization. 
It was not intended to represent the full solution, but only a scaled down version of the system.
The Event Distribution Function was implemented as a Java GUI.
This sensor board contains a CdSe photo sensor which can detect the light from the projector.
The function performs a search for an event with an identical code.
The performance evaluation results showed, however, that this level of accuracy was not needed.
The same mote code, written in nesC, for TinyOS, was used for both µSpotlight and Spotlight system implementations.
We used this implementation mainly to investigate the capabilities of the Spotlight system and tune its performance.
The sensor node is attached to the Spotlight device through a serial interface.
A code di=di1di2…dim is then constructed for each node i, such that dij=1 if tj" ∈Ti and dij=0 if tj" ∉ Ti.
The diode lasers we used ranged in power from 7mW to 35mW.
The sensor nodes that we used were Berkeley Mica2 motes equipped with MTS310 multi-sensor boards from Crossbow.
4.1 µSpotlight System The first system we built, called μSpotlight, used as the Spotlight device, an Infocus LD530 projector connected to an IBM Thinkpad laptop.
They emitted at 650nm, close to the point of highest sensitivity for CdSe photosensor.
Hence Δ guarantees that only sharp changes in the detected value generate an observed event.
The XSM mote has the photo sensor embedded in its main board.
After this fast handshaking, the recorded time stamps are exchanged.
The diode lasers were equipped with lenses that allowed us to control the divergence of the beam.
4.4 Localization Function L(T) The Localization Function is implemented in the Java GUI.
small variations around the first large signal are not considered).
Spotlight system implementation The telescope mount has worm gears for a smooth motion and high precision angular measurements.
The system is shown in Figure 10.
For our performance evaluation we implemented two Spotlight systems.
In practice this does not hold well enough.
Figure 12.
Figure 11.
