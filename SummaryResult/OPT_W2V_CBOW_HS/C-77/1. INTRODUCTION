In this paper, we are interested in the restriction of the causality relation to the subset of events defined as being the relevant events of the computation.
More precisely, given two events e and f of a distributed  computation, a crucial problem that has to be solved in a lot of distributed applications is to know whether they are causally related, i.e., if the occurrence of one of them is a consequence of the occurrence of the other.
Moreover, in this protocol, timestamps attached to messages are of size n. This raises the following question which, to our  knowledge, has never been answered: Are there efficient vector clock implementation techniques that are suitable for the IPT problem?.
This problem consists actually in determining the transitive reduction (Hasse diagram) of the causality graph generated by the relevant events of the computation.
Another efficient implementation that does not  depend on channel ordering property is described in [11].
In this context, the  determination of the immediate predecessors becomes a major issue [6].
This comes from the fact that the vector timestamp associated with e determines, for each process, the last relevant event  belong210 ing to the causal past of e, but such an event is not  necessarily an immediate predecessor of e. However, some  applications [4, 6] require to associate with each relevant event only the set of its immediate predecessors.
A main  characteristic of these computations lies in the fact that the processes do not share a common global memory, and  communicate only by exchanging messages over a  communication network.
The basic  vector clock protocol is first enriched by adding to each process a boolean vector whose management allows the processes to track the immediate predecessor events.
In that way, by associating vector timestamps with events it becomes possible to safely decide whether two events are causally related or not.
As a consequence, among all the relevant events that causally precede a given relevant event e, only a subset are its immediate predecessors: those are the events f such that there is no relevant event on any causal path from f to e. Unfortunately, given only the vector timestamp associated with an event it is not possible to determine which events of its causal past are its immediate predecessors.
Section 4 improves this protocol by providing the general condition that allows a message to carry control information whose size can be smaller than n. Section 5 provides instantiations of this condition.
It follows that detecting causal dependencies (or concurrency) on all the events of the  distributed computation is not desirable in all applications [7, 15].
Usually, according to the problem he focuses on, a  designer is interested only in a subset of the events produced by a distributed execution (e.g., only the checkpoint events are meaningful when one is interested in determining  consistent global checkpoints [12]).
More generally, these applications are interested in the very structure of the causal past.
The family of IPT  protocols is defined by a general condition that allows  application messages to piggyback control information whose size can be smaller than the system size (i.e., smaller than the number of processes composing the system).
In that sense, this family defines low cost IPT protocols when we  consider the message size.
Section 3 presents the first step of the construction that results in an IPT protocol in which each message carries a vector clock and a boolean array, both of size n (the number of processes).
This paper has three main contributions: (1) a positive answer to the previous open question, (2) the design of a family of efficient IPT protocols, and (3) a formal  correctness proof of the associated protocols.
The causal past of an event e is the set of events from which e is causally dependent.
It is shown in [4] that the tracking of immediate  predecessors allows an efficient on the fly construction of this lattice.
Vector clocks [5, 16] have been introduced to allow processes to track causality (and concurrency) between the events they produce.
This problem has been addressed for the first time (to our knowledge) in [4, 6] where an IPT protocol is described, but without correctness proof.
Finally, according to the way this condition is implemented, three IPT protocols are obtained.
Causality is a key concept to understand and master the behavior of asynchronous distributed systems [18].
The timestamp of an event produced by a process is the current value of the vector clock of the corresponding process.
If the communication pattern of the distributed computation cannot be modified, the determination has to be done without adding control messages.
Previous works have addressed the efficient  implementation of vector clocks to track causal dependence on relevant events.
Those applications are mainly related to the analysis of distributed computations.
An efficient vector clock  implementation suited to systems with fifo channels is proposed in [19].
When the immediate predecessors are used to monitor the computation, it has to be done on the fly.
The notion of causal barrier is introduced in [2, 17] to reduce the size of control information required to implement causal multicast.
This computation model defines what is known as the asynchronous distributed system model.
However, none of these papers considers the  IPT problem.
Then, a general condition is stated to reduce the size of the control  information carried by messages.
In other words, among all the events that may occur in a distributed computation, only a subset of them are  relevant.
Sections 2  introduces the computation model, vector clocks and the notion of relevant events.
Consequently, the concepts, tools and mechanisms developed for asynchronous distributed systems reveal to be both important and general.
Solving this problem requires tracking causality, hence using  vector clocks.
We call Immediate Predecessor Tracking (IPT) the  problem that consists in determining on the fly and without additional messages the immediate predecessors of relevant events.
Their aim was to reduce the size of  timestamps attached to messages.
It states abstract properties from which more concrete  properties and protocols are derived.
Some of those analyses require the construction of the  lattice of consistent cuts produced by the computation [15, 16].
A distributed computation consists of a set of processes that cooperate to achieve a common goal.
Additionally, in some circumstances, this determination has to satisfy behavior constraints.
Events that are not causally dependent are said to be  concurrent.
In addition to efficiency, the proposed approach has an interesting design property.
Section 6 provides a simulation study comparing the behaviors of the proposed protocols.
Being a strict partial order, the causality relation is  transitive.
From a  methodological point of view the paper uses a top-down approach.
They can be found in [1].)
The paper is composed of seven sections.
It is particularly important as it includes systems that span large geographic areas, and systems that are subject to  unpredictable loads.
Namely, the family is incrementally built in three steps.
(Due to space limitations, proofs of lemmas and theorems are omitted.
Moreover, message transfer delays are finite but unpredictable.
Finally, Section 7 concludes the paper.
