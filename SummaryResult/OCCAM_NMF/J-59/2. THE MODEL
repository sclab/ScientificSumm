an allocation rule ψ associates with every q ∈ q a non-empty subset ψ(q) of allocations. 
depending on the transfers, the cost shares in different  efficient allocations may differ.
this means, £i∈n t∗ i = £i∈n [ci(σ∗ ) − πi] = 0. so, (σ∗ , t∗ ) is an efficient allocation.
since σ∗ is an efficient ordering, £i∈n ci(σ∗ ) = c(n).
since (σ, t) is efficient, £i∈n ti = 0. this gives £i∈n πi = c(n).
if σ∗ = σ be an efficient ordering and t∗ i = ci(σ∗ ) − πi ∀ i ∈ n, then (σ∗ , t∗ ) is also an efficient allocation.
lemma 2. let (σ, t) be an efficient allocation and π be the vector of cost shares of jobs from this allocation.
the following straightforward lemma says that for two different efficient orderings, the cost share in one efficient allocation is  possible to achieve in the other by appropriately modifying the transfers.
233 an allocation (σ, t) is efficient for q = (n, p, θ) whenever σ is an efficient ordering and £i∈n ti = 0. the set of  efficient orderings of q is denoted as σ∗ (q) and σ∗ (q) will be used to refer to a typical element of the set.
an allocation for q = (n, p, θ) ∈ q has two components: an ordering σ and a transfer ti for every job i ∈ n. ti denotes the payment received by job i. given a transfer ti and an ordering σ, the cost share of job i is defined as, πi = ci(σ) − ti = θi   j∈n:σj ≤σi pj − ti.
from efficiency we get θjpi − θipj ≥ 0. this gives us γj ≥ γi, which is a  contradiction.
the costs to jobs in s \ {i, j} is not changed from σ∗ to σ. the difference between total costs in σ∗ and σ is given by, c(s, σ) − c(s, σ∗ ) = θjpi − θipj.
define a new ordering σ by interchanging i and j in σ∗ .
this means, we can find two  consecutive jobs i, j ∈ s (σ∗ i = σ∗ j + 1) such that γi > γj.
assume for contradiction that the statment of the lemma is not true.
lemma 1. for any s ⊆ n, let σ∗ be an efficient ordering of jobs in s. for every i = j, i, j ∈ s, if σ∗ i > σ∗ j , then γi ≤ γj.
this is also known as the weighted shortest processing time rule, first introduced by smith [26].
the following lemma shows that jobs are ordered in decreasing γ in an  efficient ordering.
sometimes, we will deal with only a subset of jobs s ⊆ n. the ordering σ will then be  defined on jobs in s only and we will write the total cost from an efficient ordering of jobs in s as c(s).
so, c(n, σ∗ ) ≤ c(n, σ) ∀ σ ∈ σ. to achieve notational simplicity, we will write the total cost in an efficient ordering of jobs from n as c(n)  whenever it is not confusing.
an efficient ordering σ∗ is the one which minimizes the  total cost incurred by all jobs.
=   i∈n piθi +   i∈n ¡pi   j∈fi(σ) θj¢.
c(n, σ) =   i∈n ci(σ) =   i∈n piθi +   i∈n ¡θi   j∈pi(σ) pj¢.
the total cost incurred by all jobs due to an ordering σ can be written in two ways: (i) by summing the cost incurred by every job and (ii) by summing the costs inflicted by a job on other jobs with their own processing cost.
given an ordering of jobs σ, the cost incurred by job i is given by ci(σ) = piθi + θi   j∈pi(σ) pj.
we will denote γi = θi pi .
pi is the processing time and θi is the cost per unit waiting time of job i. thus, a queueing problem is defined by a list q = (n, p, θ) ∈ q, where q is the set of all possible lists.
every job i is identified by two parameters: (pi, θi).
σ : n → n is an ordering of jobs in n and σi denotes the position of job i in the ordering σ. given an ordering σ, define fi(σ) = {j ∈ n : σi < σj} and pi(σ) = {j ∈ n : σi > σj}.
, n}.
the set of jobs are denoted as n = {1, .
there are n jobs that need to be served by one server which can process only one job at a time.
