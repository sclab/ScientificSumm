given this, we can focus on truthful mechanisms in the rest of the paper.
however, because here we focus on flatly represented outcome and type spaces, this is not a concern here.)
(there are computational difficulties with applying the revelation principle in large combinatorial outcome and type spaces [7, 22].
this  argument is known in the mechanism design literature as the  revelation principle [16].
since the interface layer acts strategically on each agent"s behalf, there is never an incentive to report falsely to the interface layer; and hence, the types reported by the interface layer are the strategic types that would have been reported  without the interface layer, so the results are exactly as they would have been with the original mechanism.
the resulting outcome is the outcome of the new mechanism.
the agents report their preferences (or types) to the interface layer; subsequently, the interface layer inputs into the original mechanism the types that the agents would have strategically reported to the original mechanism, if their types were as declared to the interface layer.
we build an interface layer between the agents and the original  mechanism.
this does, however, turn out to be the case: given any mechanism, we can construct a nonmanipulable  mechanism whose performance is identical, as follows.
after all, it is not immediately  obvious that there are no manipulable mechanisms that, even when agents report their types strategically and hence  sometimes untruthfully, still reach better outcomes (according to whatever objective we use) than any nonmanipulable  mechanism.
nonmanipulable mechanisms before we define the computational problem of automated mechanism design, we should justify our focus on  nonmanipulable mechanisms.
