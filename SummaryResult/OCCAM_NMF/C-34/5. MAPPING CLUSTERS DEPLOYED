if such kind of a correct key path exists, then through which node a can establish an indirect pairwise key with node b. otherwise, node a fails to establish an indirect pairwise key with node b. and node a will tries again to establish an indirect pairwise key with node b some time later. 
step 4: algorithm exits.
then let i0=c(b1…bn,a"1…a"m), i1=(b1…bn,b"1 a"2…a"m),…, is=b(b1…bn,b"1 b"2…b"s a"s+1…a"m), and each node it in the above nodes series find a route to its neighboring node it+1 on the basis of the location information (detailed routing algorithms based on location information can see the references[11-14]).
step 3: otherwise, node a can find a route to c(b1…bn, a"1…a"m) according to the algorithm i or algorithm ii.
step 2: if a"1…a"m = b"1…b"m, then node a can find a route to b according to the routing algorithms of hypercube [9-10].
step 1: obtain the code strings of node a and b: a ← (a1…an,a"1…a"m), b ← (b1…bn,b"1…b"m), where aj, bj [0,∈ u-1], a"j, b"j [0,∈ v-1].
output: a correct key path from node a to b in h(k,u,m,v,n).
input: sub-sensor network h(k,u,m,v,n), which has some compromised /fault sensors and fault links, and two reachable nodes a(a1…an,a"1…a"m) and b(b1…bn,b"1…b"m) in h(k,u,m,v,n), where a"t ≠ b"t, t∈[1,s], a"t=b"t, t >s.
in this section, we will propose a dynamic path key discovery algorithm as follows, which can improve the probability of key path effectively: algorithm i: dynamic key path establishment algorithm based on h(k,u,m,v,n) model for cluster deployed sensor networks.
for example: considering the key path establishment example given in the above section based on figure.2: a((012),(1234)) → c((112),(1234)) → d((122),(1234)) → e((121),(1234)) → f((121),(2234)) → b((121),(2334)), supposing that node f((121),(2234)) has compromised, then from figure.3, we can know that there exists another alternative key path as a((012),(1234)) → c((112),(1234)) → d((122),(1234)) →e((121),(1234)) → m((121),(1334)) → b((121),(2334)), which can be used to establish the indirect pairwise key between node a and b, where node e shall route through nodes d and k to establish direct pairwise key with node m, and node m shall route through nodes n, o, g, h, i, j to establish direct pairwise key with node b. since the sensors are source limited, so they are easy to die or out of the communication radius, therefore the algorithm proposed in the above section cannot guarantee to establish correct key path efficiently.
figure.3 alternative key path establishment example.
from the following example we can know that there are many parallel paths in the h(k,u,m,v,n) model for any two given source and destination nodes, since the h(k,u,m,v,n) model is high fault-tolerant[9,10] .
and the proposed algorithm cannot find an alternative key path when there exist some compromised nodes or some intermediate nodes not in the communication radius, even that there exists other alternative key paths in the sensor network.
6.4 dynamic path key discovery the path key discovery algorithm proposed in the above section can establish a key path correctly, only when there exist no compromised nodes in the whole sensor network, since the key path is computed out beforehand.
since d=t, according to the construction properties of h(k,u,m,v,n), it is easy to know that there exist t-1 intermediate nodes i1,…,it-1, in the logical space h(k,u,m,v,n), which satisfy that the distance between any two neighboring nodes in the nodes series a,  i1,…,it1, b equals to 1. so according to the theorem 1, we can know that nodes a, i1,…,it-1, b form a correct key path between node a and b. if any two neighboring nodes in the nodes series a, i1,…,it-1, b can communicate directly, then node a can establish indirect pairwise key with node b through those t-1 intermediate nodes.
proof: supposing that the distance between node a(i1i2…in, j1j2…jm) and b (i'1i'2…i'n, j'1j'2…j'm) is d=d1+ d2, where d1=dh(i1i2…in, i'1i'2…i'n), d2=dh(j1j2…jm, j'1j'2…j'm).
that is to say, node a can establish indirect pairwise key with node b through t-1 intermediate nodes.
57 according to the properties of h(k,u,m,v,n) model, we can prove that the following theorem by combing the proof of theorem 2: theorem 3: supposing that there exist no compromised nodes in the sensor network, and the distance between node a and b, then there exists a shortest key path with k distance between node a and b logically.
for example: in the above figure.2, node a((012),(1234)) can establish pairwise key with node b((121),(2334)) through the following key path: a((012),(1234)) → c((112),(1234)) → d((122),(1234)) → e((121),(1234)) → f((121),(2234)) → b((121),(2334)), where node f shall route through nodes g, h, i, j to establish direct pairwise key with node b.
figure.2 key path establishment example.
once the key path p is computed out, then node a can send messages to b along the path p to establish indirect pairwise key with node b. fig.2 presents a example of key path establishment.
from theorem 2, it is easy to know that any source node a can compute out a key path p to the destination node b according to the above algorithm, when there are no compromised nodes in the sensor network.
step 2: in those nodes series a(i1i2…in,j1j2…jm), (i'1i2 i3…in,j1j2…jm), (i'1i'2 i3…in,j1j2…jm),…,(i'1i'2…i'n,j1j2…jm) and (i'1i'2…i'n,j1'j2 j3…jm), (i'1i'2…i'n,j'1j'2 j3…j'm-1 jm),…, (i'1i'2…i'n, j'1j'2…j'm-1 jm), b (i'1i'2…i'n,j'1j'2…j'm), the neighboring nodes select their common polynomial share to establish direct pairwise key.
so, it is obvious that there exists a path key between nodes a and b. according to theorem 2, we present the detailed description of the path key discovery algorithm as follows: step 1: compute out the intermediate nodes (i'1i2 i3…in,j1j2…jm), (i'1i'2 i3…in,j1j2…jm),…,(i'1i'2…i'n, j1j2…jm) and (i'1i'2…i'n,j1'j2 j3…jm), (i'1i'2…i'n,j'1j'2 j3…j'm-1 jm),…,(i'1i'2…i'n,j'1j'2…j'm-1 jm) from the source node a(i1i2…in,j1j2…jm) and the destination node b (i'1i'2…i'n,j'1j'2…j'm).
in addition, in those nodes, the distance between any two neighboring nodes is 1, so from theorem 1, it is easy to know that there exists direct pairwise key between any two neighboring nodes among those nodes.
obviously, from the supposing condition of the whole sensor network forms a connected graph, there is a route among those nodes.
for nodes (i'1i'2…i'n,j1j2…jm), (i'1i'2…i'n,j'1 j2 j3…jm), (i'1i'2…i'n,j'1j'2 j3…jm-1 jm),…, (i'1i'2…i'n,j'1j'2…j'm-1jm), since they have the same out-cluster-hypercube-node-codes with the node b(i'1i'2…i'n,j'1j'2…j'm), so nodes (i'1i'2…i'n,j1j2…jm), (i'1i'2…i'n,j'1 j2 j3…jm), (i'1i'2…i'n,j'1j'2 j3…jm-1 jm),…, (i'1i'2…i'n,j'1j'2…j'm-1 jm) and node b belong to a same logical hypercube.
so, according to the supposing condition of the nodes in the same cluster form a connected graph, there is a route among those nodes.
obviously, nodes a(i1i2…in, j1j2…jm) ,(i'1i2 i3…in, j1j2…jm),(i'1i'2 i3…in, j1j2…jm),…,(i'1i'2…i'n, j1j2…jm) belong to the same cluster.
if d>1, then there exists a path key between nodes a and b. proof: let d1=a, d2=b, then we can think that it ≠ i't, when 1 ≤ t ≤ a; but it=i't, when t>a; and jt ≠ j't, when 1 ≤ t ≤ b; but jt=j't, when t>b.
6.3 path key discovery if d>1, then node a can establish path key with node b according to the following theorem 2: theorem 2: for any two sensor nodes a(i1i2…in,j1j2…jm) and b (i'1i'2…i'n,j'1j'2…j'm) in the sensor network, supposing that the distance between nodes a and b is d= d1+ d2, where d1=dh(i1i2…in, i'1i'2…i'n) and d2=dh(j1j2…jm, j'1j'2…j'm).
so, there exists a direct pairwise key f m jjjinii m >< −121 ,...,,,,...,2,1 (jm, j"m) between nodes a and b. according to theorem 1, we present the detailed description of the direct pairwise key discovery algorithm as follows: step 1: obtain the node ids and cluster ids of the source node a and destination node b; step 2: compute out the distance between nodes a and b: d= d1+ d2; step 3: if d1=1, d2=0, then select out a common polynomial share of nodes a and b from { f iiil n 1 ,...,,, 32 >< ,..., f n iiil n >< −121 ,...,,, } to establish direct pairwise key; step 4: if d1=0, d2=1, then select out a common polynomial share of nodes a and b from { f jjinii m 1 ,...,,,...,2,1 2 >< ,..., f m jjjinii m >< −121 ,...,,,,...,2,1 } to establish direct pairwise key; step 5: otherwise, there exists no direct pairwise key between nodes a and b. and then turn to the following path key discovery process.
2) if d1=0, d2=1: from d2=1 ⇒ there is only one position different between j1j2…jm and j"1j"2…j"m. let jt=j"t, when 1 ≤ t ≤  m1, and jm ≠ j"m. since d1=0 ⇒ i1i2…in equals to i"1i"2…i"n ⇒ f m jjjinii m >< −121 ,...,,,,...,2,1 (jm, j"m)= f m jjji nii m >′′′′′′< −121 ,...,,,,...,2,1 (j"m,jm).
so, there exists a direct pairwise key f n iiil n >< −121 ,...,,, (in,i"n) between nodes a and b.
supposing that nodes a, b belong to the same cluster l, then from d1=1 ⇒ there is only one position different between i1i2…in and i"1i"2…i"n. let it=i"t, when 1 ≤ t ≤ n-1, and in ≠ i"n ⇒ f n iiil n >< −121 ,...,,, (in,i"n)= f n iiil n >′′′< −121 ,...,,, (i"n,in).
1) if d1=1, d2=0: from d2=0, there is nodes a, b belong to the same cluster.
if d=1, then there exists a direct pairwise key between nodes a and b. poof: since d=1, then there is d1=1, d2=0, or d1=0, d2=1.
if d=1, then node a obtains the direct pairwise key between itself and node b according to the following theorem 1: theorem 1: for any two sensor nodes a(i1i2…in,j1j2…jm) and b (i'1i'2…i'n,j'1j'2…j'm) in the sensor network, supposing that the 56 distance between nodes a and b is d= d1+ d2, where d1=dh(i1i2…in, i'1i'2…i'n) and d2=dh(j1j2…jm, j'1j'2…j'm).
firstly, node a computes out the distance between itself and node b: d= d1+ d2, where d1=dh(i1i2…in, i'1i'2…i'n) and d2=dh(j1j2…jm, j'1j'2…j'm).
6.2 direct pairwise key discovery if the node a(i1i2…in,j1j2…jm) in the sensor network wants to establish pairwise key with a node b (i'1i'2…i'n,j'1j'2…j'm), then node a can establish pairwise key with the node b trough the following methods.
step 3: key setup server assigns a unique cluster id: l to all the sensor nodes deployed in the same round, where 1 ≤ l ≤ k. step 4: key setup server predistributes m+n bivariate polynomials { f iiil n 1 ,...,,, 32 >< (i1,y),…, f n iiil n >< −121 ,...,,, (in,y); f jjinii m 1 ,...,,,...,2,1 2 >< ( j1,y),…, f m jjinii m >< −11 ,...,,,...,2,1 ( jm,y) } and the corresponding polynomial ids to the sensor node deployed in the lth round and with id (i1i2…in, j1j2…jm).
then we can predistribute keys for each sensor node on the basis of the h(k,u,m,v,n) model as follows: step 1: key setup server randomly generates a bivariate polynomials pool such as the following: f={ f i iiil n >< −121 ,...,,, (x,y), f j jjjinii m >< −121 ,...,,,,...,2,1 (x,y) | 0 ≤ iii n 121 ... −≤≤≤ ≤ v-1, 1 ≤ i ≤ n, 1 ≤ l ≤ k; 0 ≤ jjj m 121 ... −≤≤≤ ≤ u-1 , 1 ≤ j ≤ m} with vn *m*um-1 +[n/vn ]*n*vn-1 different t-degree bivariate polynomials over a finite field fq, and then assigns a unique polynomial id to each bivariate polynomial in f. step 2: in each round, key setup server assigns a unique node id: (i1i2…in,j1j2…jm) to each sensor node from small to big, where 0 ≤ i1,i2,…in ≤ v-1, 0 ≤ j1,j2,…jm ≤ u-1.
6.1 generation of polynomials pool and key predistribution supposing that, the sensor network includes n nodes, and is deployed through k different rounds.
the new h(k,u,m,v,n) model-based pairwise key establishment algorithm includes three main steps: (1) generation of the polynomials pool and key predistribution, (2) direct pairwise key discovery, (3) path key discovery.
6. h(k,u,m,v,n) model-based pairwise key predistribution algorithm for sensor networks in order to overcome the drawbacks of polynomial-based and polynomial pool-based key predistribution algorithms, this paper proposed an innovative h(k,u,m,v,n) model-based key predistribution scheme and pairwise key establishment algorithm, which combines the advantages of polynomial-based and key pool-based encryption schemes, and is based on the kdc and polynomials pool-based key predistribution models.
consequently, the whole sensor network has been mapped into a k-levels- hierarchical hypercube model.
then, the sensor nodes in each cluster can be encoded with the in-cluster-hypercube-node-codes, and the sensor nodes in the k different clusters with the same  in-clusterhypercube-node-codes can be encoded with the  out-clusterhypercube-node-codes according to the definition 5 respectively.
sensor networks to h(k,u,m,v,n) obviously, from the description in section 3 and 4, we can know that the clusters deployed sensor network can be mapped into a  klevels- hierarchical hypercube model as follows: at first, the k clusters in the sensor network can be mapped into k different levels (or hypercubes) in the k-levels- hierarchical hypercube model.
