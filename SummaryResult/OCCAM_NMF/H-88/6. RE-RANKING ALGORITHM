in practice, re-ranking an inex result set requires less than 200ms on a three-year-old desktop pc. 
combining these observations  produces an overall time complexity of o((n + mh) log n).
since a node may have at most h ancestors, where h is the maximum height of any tree in the collection, each of the m iterations requires o(h log n) time.
thus, the total time for all calls to down is o(n log n), and we may temporarily ignore lines 8-10 of figure 5 when considering the time complexity of the loop over lines 2-15. during each iteration of this loop, a node and each of its ancestors are removed from a priority queue and then added back into a priority queue.
during each call to down a node may be moved from s to f, requiring o(log n) time.
thereafter, the reported flag of its parent is true.
however, since the contents of each descendant are entirely contained in a reported  element its final score may be computed, and it is removed from s and added to f. in order to determine the time complexity of the  algorithm, first note that a node may be an argument to down at most once.
the tree traversal routines, up and down are given in  figure 6. the up routine removes each ancestor node from s, adjusts its term frequency values, recomputes its score, and adds it back into s. the adjustment of the term frequency values (line 3) adds to y.g only the previously unreported term occurrences in x. re-computation of the score on line 4 uses equations 1 and 2. the down routine performs a similar operation on each descendant.
node"s ancestors (lines 8-10) and descendants (lines 12-14) adjusting the scores of these nodes.
0.0 0.02 0.04 0.06 0.08 0.10 0.12 0.14 0.16 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 0.25 0.26 0.27 0.28 0.29 0.30 0.31 0.32 0.33 0.34 0.35 0.36 meanaverageprecision(inex-2002) xmlcumulatedgain(xcg) alpha map (strict) map (generalized) map (sog) xcg (sog2) figure 7: impact of α on xcg and inex-2002 map (inex 2004 co topics; assessment set i).
1 up(x, y) ≡ 2 s.remove(y) 3 y.g ← y.g + x.f − x.g 4 recompute y.score 5 s.add(y) 6 if y is not a root node then 7 up (x, y.parent) 8 end if 9 10 down(x) ≡ 11 if not x.reported then 12 s.remove(x) 14 x.g ← x.f 15 recompute x.score 16 if x.score > 0 then 17 f.add(x) 18 end if 19 x.reported ← true 20 foreach y ∈ x.children do 21 down (y) 22 end do 23 end if figure 6: tree traversal routines called by the  reranking algorithm.
at the start of each iteration, the unreported node at the front of s has the greatest adjusted score, and it is removed and added to f. the algorithm then traverses the 1 f ← ∅ 2 for i ← 1 to m do 3 x ← s.front() 4 s.remove(x) 5 x.reported ← true 6 f.add(x) 7 8 foreach y ∈ x.children do 9 down (y) 10 end do 11 12 if x is not a root node then 13 up (x, x.parent) 14 end if 15 end do figure 5: re-ranking algorithm - as input, the  algorithm takes a priority queue s, containing xml nodes ranked by their initial scores, and returns its results in priority queue f, ranked by adjusted scores.
the core of the re-ranking algorithm is presented in  figure 5. the algorithm takes as input the priority queue s containing the initial ranking, and produces the top-m  reranked nodes in the priority queue f. after initializing f to be empty on line 1, the algorithm loops m times over lines  215, transferring at least one node from s to f during each iteration.
each priority queue pq supports three operations: pq.front() - returns the node with greatest score pq.add (x) - adds node x to the queue pq.remove(x) - removes node x from the queue when implemented using standard data structures, the front operation requires o(1) time, and the other operations  require o(log n) time, where n is the size of the queue.
given a term t ∈ q, let ft be the component of x.f corresponding to t, and let gt be the component of x.g corresponding to t, then: xt = ft − α · gt (2) for processing by the re-ranking algorithm, nodes are stored in priority queues, ordered by decreasing score.
the score is computed using equation 1, with the xt value for each term determined by a combination of the values in x.f and x.g.
the score field contains the current bm25 score for the element, which will change as the values in x.g change.
the vector x.g is initially zero and is updated by the algorithm as elements are reported.
the vector x.f contains term frequency information corresponding to each term in the query.
associated with this node are fields storing the length of element, term frequencies, and other information required by the re-ranking algorithm, as follows: x.f - term frequency vector x.g - term frequency adjustments x.l - element length x.score - current okapi bm25 score x.reported - boolean flag, initially false x.children - set of child nodes x.parent - parent node, if one exists these fields are populated during the initial ranking process, and updated as the algorithm progresses.
an element is represented by the node x ∈ n at its root.
output from the algorithm is a list of the top m elements, ranked according to their adjusted scores.
during the initial ranking the xml tree is  dynamically re-constructed to include only those nodes with  nonzero bm25 scores, so n may be considerably less than |n |.
the re-ranking algorithm operates over xml trees, such as the one appearing in figure 2. input to the algorithm is a list of n elements ranked according to their initial bm25 scores.
