this modifier facilitates the creation of service management methods.
the method to authenticate is pluggable and might be by pass-phrase, internet address or any other  authentication scheme.
if a method is marked with admin an authentication is necessary.
finally we provide another modifier to mark administrative  operations.
this peer-to-peer based behavior as known from napster is transparent to the client and can be switched on and off depending on  environment conditions like load and community as needed.
now the  clientstub fetches the data from the offered location and responds as if it was supplied by the server object.
for example if a client-stub offers a method which results in a file transfer it is possible to integrate a custom protocol that forwards a modified request to the replicated object which returns not the file as in the common case but urls that point to clients that previously requested the file.
apart form methods that are usual static this is useful to implement client-side contribution and interaction.
in this case the  idlcompiler creates placeholder for local execution.
furthermore one can mark methods as local which indicates that they can be locally processed.
these are retain to mark non-modifying operations which allows faster responses and load balancing of those requests.
the idl extension consists of additional modifiers that affect code generation for client and server side.
the replicas are synchronized via a group communication framework.
to keep the connection between clients and the replicated object we use time-bounded references [10] that restrict the migration but make the usage of location services (to cope with outdate references) obsolete.
this is achieved by generating special client-side stubs that communicate with one of the replicas.
as we would like to tolerate node crashes and the service should be available during migration we support the active replication of the service.
this can be achieved by using value type based approach to describe the service state as done in [9] or using the language supplied serialization mechanisms.
additionally it should be possible to migrate the service.
this service then can be started and executed on the grid as a common servant.
the core idea is to develop a service in usual client/server fashion as it is done in plain corba.
as this set of features requires an enormous  implementation effort to do it anew for each service implementation we support the development of decentralized adaptive  services through a framework and an extended version of idl in combination with a special idl-compiler [8].
the management interface offers methods to start, stop, and configure service instances.
each service has at least two interfaces: one for management tasks and another service specific for the end user.
usually every part of the object is mobile and can be migrated if necessary.
this object expands or shrinks in the scope spanned by the associated service environment depending on the service demands and for fault-tolerance reasons.
such a service is represented by a fragmented object.
model in edas a decentralized, adaptive service normally matches a traditional service accessed by users like a web server, an instant messaging server or a source code repository.
