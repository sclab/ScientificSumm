occurring collaboration conflicts are solved and described in [3].
rtcs 1 combines the received update information with the information in his sessionmanager and sends the editor data to the affected editors, in this case to editor a and b, where the changes are immediately shown.
after the insertion, database 1 sends an update message (according to the update protocol discussed before) to real-time server component 1 (via as 1).
the insert operation is passed to application server 1, which in turns, passes it to the database 1, where an insert operation is invoked; the characters are inserted according to the algorithm discussed in the previous section.
considering that editor a (connected to database 1 and 4) and editor b (connected to database 1 and 2) are working on the same document stored in database 1. editor b now inserts a character into this document.
editors are connected to one or more real-time server components and to the corresponding databases.
each database is connected to an application server (as) and each application server is connected to a real-time server component (rtsc).
of its architecture: four databases are distributed over a peer-to-peer network.
releaselocks committa send update information to the real-time server component sendupdate(updatenmessage) read update message and inform affected editors of the change read(updatemessage) allocate editors(updatemessage, sessionmanager) sendmessage(editordata) 3.2 insert characters example figure 1 gives a snapshot the system, i.e.
updatestring(characteroids, prevcharoid, nextcharacteroid) release all locks and commit transaction.
checkpreceding(prevcharoid) = isok(isactive, charactervalue) ⇐ π isactive, charactervalue (ϑ oid = nextcharacteroid(char)) checksucceeding(nextcharacteroid) = isok(isactive, charactervalue)⇐ π isactive, charactervalue (ϑ oid = nextcharacteroid(char)) update characters before and after the string to be inserted.
for each character ci of characteroids: insertchar(ci, p, n) whereas ci ∈ { c1,…, cn } check if the preceding and succeeding characters are active or if it is the beginning or the end of the document.
characteroids={ c1, …, cn } each character of the string is inserted at the appropriate position by linking the preceding and the succeeding character to it.
lock(prevcharid) at this time the list characteroids contains the characters c1 to cn that shall be inserted.
getprevious(nextcharacteroid) = prevchar(prevcharoid) ⇐ π after ϑoid = nextcharacteroid(char)) acquire the lock for the character that is situated in the document before the character that follows the string which shall be inserted.
startta select the character that is situated before the character that follows the string to be inserted.
allocateeditors(updateinformationmessage, sessionmanager) = returns the affected editors the function sendmessage(editordata) sends the editor part of the updatemessage to the editors sendmessage(editordata) in tendax, the insert algorithm is implemented in the class method insertchars of the class char which is depicted in figure 2. the relevant parameters for the definitions beneath, are introduced in the following list: - nextcharacteroid: oid of the character situated next to the string to be inserted - previouscharacteroid: oid of the character situated previously to the string to be inserted - characteroids (list): list of character which have to be inserted thus, the insertion of characters can be defined stepwise as follows: start a transaction.
read(updateinformationmessage) the function allocateditors checks on the base of the updatemessage and the sessionmanager, which editors have to be informed.
sendupdate(updatemessage) the function read is used in the real-time server component to read the updatemessage.
45 checksucceeding(c) = return status and charactervalue of the next character the function checkcharvalue determines the charactervalue of a character c. checkcharvalue(c) = return charactervalue of character c the function sendupdate sends an update message (updatemessage) from the database to the real-time server component.
checkpreceding(c) = return status and charactervalue of the previous character the function checksucceeding determines the next character's charactervalue of a character c and if the next character's status is active.
releaselocks = release all locks the function getprevious returns the previous character and getnext returns the next character of a character c. getprevious(c) = return previous character of character c getnext(c) = return next character of character c the function linkbefore links a preceding character p with a succeeding character x and the function linkafter links a succeeding character n with a preceding character y. linkbefore(p,x) = link character p to character x linkafter(n,y) = link character n to character y the function updatestring links a character p with the first character c1 of a character list l and a character n with the last character cn of a character list l updatestring(l, p, n) = linkbefore(p cl)∧ linkafter(n, cn ) the function insertchar inserts a character c in the table char with the fields after set to a character p and before set to a character n. insertchar(c, p, n) = linkafter(c,p) ∧ linkbefore(c,n) ∧ linkbefore(p,c) ∧ linkafter(n,c) the function checkpreceding determines the previous character's charactervalue of a character c and if the previous character's status is active.
lock(c) = acquire the lock for character c success : return 1, no success : return 0 the function releaselocks releases all locks that a transaction has acquired so far.
checkwriteaccess(s) = check if write access for document session s is granted the function lock acquires an exclusive lock for a character c and returns 1 for a success and 0 for no success.
committa = commit transaction the function checkwriteaccess checks if the write access for a document session s is granted.
startta = start transaction the function committa commits a transaction that was started.
β=beginning of document ε=end of document the function startta starts a transaction.
c = character p=previous character n = next character l = list of characters the symbol c1 stands for the first character in the list l, ci stands for a character in the list l at the position i, whereas i is a value between 1 and the length of the list l, and cn stands for the last character in the list l. c1 = first character in list l ci = character at position i in list l cn = last character in list l the symbol β stands for the special character that marks the beginning of a document and ε stands for the special character that marks the end of a document.
3.1 insert characters algorithm the symbol c stands for the object character, p stands for the previous character, n stands for the next character of a character object c and the symbol l stands for a list of character objects.
the algorithm is simplified for this purpose.
the character insertion is based on the tendax insert algorithm which is formally described in the following.
insert operations are the mostly used operations in a (collaborative) editing system.
the proposed architecture is validated on the example of a character insertion.
