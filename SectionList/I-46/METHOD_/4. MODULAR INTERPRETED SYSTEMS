The idea behind distributed systems (multi-agent systems even
more so) is that we deal with several loosely coupled components,
where most of the processing goes on inside components (i.e., 
locally), and only a small fraction of the processing occurs between
the components. Interaction is crucial (which makes concurrent
programs an insufficient modeling tool), but it usually consumes
much less of the agent"s resources than local computations (which
makes the explicit transition tables of CGS, CEGS, and interpreted
systems an overkill). Modular interpreted systems, proposed here,
extrapolate the modeling idea behind interpreted systems in a way
that allows for a tight control of the interaction complexity.
DEFINITION 4. A modular interpreted system (MIS) is defined
as a tuple
S = Agt, env, Act, In ,
where Agt = {a1, ..., ak} is a set of agents, env is the environment,
Act is a set of actions, and In is a set of symbols called interaction
alphabet. Each agent has the following internal structure:
ai = Sti, di, outi, ini, oi, Πi, πi , where:
• Sti is a set of local states,
• di : Sti → P(Act) defines local availability of actions; for
convenience of the notation, we additionally define the set of
situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)},
• outi, ini are interaction functions; outi : Di → In refers to
the influence that a given situated action (of agent ai) may
possibly have on the external world, and ini : Sti ×Ink
→ In
translates external manifestations of the other agents (and
the environment) into the impression that they make on
ai"s transition function depending on the local state of ai,
• oi : Di × In → Sti is a (deterministic) local transition 
function,
• Πi is a set of local propositions of agent ai where we require
that Πi and Πj are disjunct when i = j, and
• πi : Πi → P(Sti) is a valuation of these propositions.
The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the
same structure as an agent except that it does not perform actions,
and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.
Within our framework, we assume that every action is executed
by an actor, that is, an agent. As a consequence, every actor is
explicitly represented in a MIS as an agent, just like in the case of
CGS and CEGS. The environment, on the other hand, represents the
(passive) context of agents" actions. In practice, it serves to capture
the aspects of the global state that are not observable by any of the
agents.
The input functions ini seem to be the fragile spots here: when
given explicitly as tables, they have size exponential wrt. the 
number of agents (and linear wrt. the size of In). However, we can
use, e.g., a construction similar to the one from [16] to represent
interaction functions more compactly.
DEFINITION 5. Implicit input function for state q ∈ Sti is given
by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an 
interaction symbol, and each ϕj is a boolean combination of 
propositions ˆηi
, with η ∈ In; ˆηi
stands for η is the symbol currently
generated by agent i. The input function is now defined as 
follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that
{ˆ1
1, ..., ˆk
k, ˆenv
env} |= ϕj. It is required that ϕn ≡ , so that the 
mapping is effective.
REMARK 1. Every ini can be encoded as an implicit input 
function, with each ϕj being of polynomial size with respect to the 
number of interaction symbols (cf. [16]).
Note that, for some domains, the MIS representation of a system
requires exponentially many symbols in the interaction alphabet In.
In such a case, the problem is inherent to the domain, and ini will
have size exponential wrt the number of agents.
4.1 Representing Agent Systems with MIS
Let Stg = (
Qk
i=1 Sti)×Stenv be the set of all possible global states
generated by a modular interpreted system S.
DEFINITION 6. The unfolding of a MIS S for initial states Q ⊆
Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k
is defined as follows:
• Agt = {1, ..., k} and Act = Act,
• St is the set of global states from Stg which are reachable
from some state in Q via the transition relation defined by o
(below),
• Π =
Sk
i=1 Πi ∪ Πenv,
• For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env,
we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p),
• d (i, q) = di(qi) for global state q = q1, ..., qk, qenv ,
• The transition function is constructed as follows. Let q =
q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action
profile s.t. αi ∈ d (i, q). We define inputi(q, α) =
ini
`
qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1),
. . . , outk(qk, αk), outenv(qenv)
´
for each agent i = 1, . . . , k,
and inputenv(q, α) = inenv
`
qenv, out1(q1, α1), . . . , outk(qk, αk)
´
.
Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . ,
ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ;
The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901
• For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff
qi = qi .6
REMARK 2. Note that MISs can be used as representations of
CGSs too. In that case, epistemic relations ∼i are simply omitted in
the unfolding. We denote the unfolding of a MIS S for initial states
Q into a CGS by cgs(S, Q).
Propositions 3 and 5 state that modular interpreted systems can
be used as representations for explicit models of multi-agent 
systems. On the other hand, these representations are not always 
compact, as demonstrated by Propositions 7 and 8.
PROPOSITION 3. For every CEGS M, there is a MIS SM
and a
set of global states Q of SM
such that cegs(SM
, Q) is isomorphic to
M.7
PROOF. Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k
be a CEGS. We construct a MIS SM
= {a1, . . . , ak}, env, Act, In
with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env =
Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global
states, as follows.
• In = Act ∪ St ∪ (Actk−1
× St),
• Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of i"s
indistinguishability classes in M),
• Stenv = St,
• di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since
d(i, q) = d(i, q ) whenever q ∼i q ),
• outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q,
• ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) =
α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k};
inenv(q, α1 . . . , αk) = α1, . . . , αk ;
ini(x) and inenv(x) are arbitrary for other arguments x,
• oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) =
[o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i );
oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk);
oi and oenv are arbitrary for other arguments,
• Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π,
• πenv(p) = π(p)
• Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St}
Let M = cegs(SM
, Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .
We argue that M and M are isomorphic by establishing a 
oneto-one correspondence between the respective sets of states, and
showing that the other parts of the structures agree on 
corresponding states.
First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q
and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have
o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1)
Let ˆq = o (ˆq , α). Now, for any i: inputi(ˆq , α) = ini([q ]∼i ,
out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1),
. . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1,
6
This shows another difference between the environment and the
agents: the environment does not possess knowledge.
7
We say that two CEGS are isomorphic if they only differ in the
names of states and/or actions.
. . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q . Similarly, we get
that inputenv(ˆq , α) = α1, . . . , αk . Thus we get that o (ˆq , α) =
o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)),
oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . ,
[o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) . Thus, ˆq =
[q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes
the proof of (1).
We now argue that St = Q. Clearly, Q ⊆ St . Let ˆq ∈ St ;
we must show that ˆq ∈ Q. The argument is on induction on the
length of the least o path from Q to ˆq. The base case, ˆq ∈ Q, is
immediate. For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q,
and then we have that ˆq ∈ Q by (1). Thus, St = Q.
Now we have a one-to-one correspondence between St and St :
r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St . It remains to
be shown that the other parts of the structures M and M agree on
corresponding states:
• Agt = Agt,
• Act = Act,
• Π =
Sk
i=1 Πi ∪ Πenv = Π,
• For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈
πenv(p) iff q ∈ π(p) (same valuations at corresponding states),
• d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q),
• It follows immediately from (1), and the fact that Q = St ,
that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r
iff o(q , α) = r (transitions on the same joint action in 
corresponding states lead to corresponding states),
• [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i =
[r ]∼i iff q ∼i r (the accessibility relations relate 
corresponding states), which completes the proof.
COROLLARY 4. For every CEGS M, there is an ATLir-equivalent
MIS S with initial states Q, that is, for every state q in M there is
a state q in cegs(S, Q) satisfying exactly the same ATLir formulae,
and vice versa.
PROPOSITION 5. For every CGS M, there is a MIS SM
and a set
of global states Q of SM
such that cgs(SM
, Q) is isomorphic to M.
PROOF. Let M = Agt, St, Act, d, o, Π, π be given. Now, let
ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary 
accessibility relations ∼i over St. By Proposition 3, there exists a MIS
S
ˆM
with global states Q such that ˆM = cegs(S
ˆM
, Q) is isomorphic
to ˆM. Let M be the CGS obtained by removing the accessibility
relations from ˆM . Clearly, M is isomorphic to M.
COROLLARY 6. For every CGS M, there is an ATL-equivalent
MIS S with initial states Q. That is, for every state q in M there is a
state q in cgs(S, Q) satisfying exactly the same ATL formulae, and
vice versa.
PROPOSITION 7. The local state spaces in a MIS are not 
always compact with respect to the underlying concurrent epistemic
game structure.
PROOF. Take a CEGS M in which agent i has always perfect 
information about the current global state of the system. When 
constructing a modular interpreted system S such that M = cegs(S, Q),
we have that Sti must be isomorphic with St.
902 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)
The above property is a part of the interpreted systems heritage.
The next proposition stems from the fact that explicit models (and
interpreted systems) allow for intensive interaction between agents.
PROPOSITION 8. The size of In in S is, in general, exponential
with respect to the number of local states and local actions. This is
the case even when epistemic relations are not relevant (i.e., when
S is taken as a representation of an ordinary CGS).
PROOF. Consider a CGS M with agents Agt = {1, ..., k}, global
states St =
Qk
i=1{qi
0, ..., qi
i}, and actions Act = {0, 1}, all enabled
everywhere. The transition function is defined as
o( q1
j1
, ..., qk
jk
, α1, ..., αk) = q1
l1
, ..., qk
lk
, where li = (ji + α1 +
... + αk) mod i. Note that M can be represented as a modular 
interpreted system with succinct local state spaces Sti = {qi
0, ..., qi
i}.
Still, the current actions of all agents are relevant to determine the
resulting local transition of agent i.
We will call items In, outi, ini the interaction layer of a 
modular interpreted system S; the other elements of S constitute the local
layer of the MIS. In this paper we are ultimately interested in model
checking complexity with respect to the size of the local layer. To
this end, we will assume that the size of interaction layer is 
polynomial in the number of local states and actions. Note that, by
Propositions 7 and 8, not every explicit model submits to compact
representation with a MIS. Still, as we declared at the beginning of
Section 4, we are mainly interested in a modeling framework for
systems of loosely coupled components, where interaction is 
essential, but most processing is done locally anyway. More 
importantly, the framework of MIS allows for separating the interaction
of agents from their local structure to a larger extent. Moreover, we
can control and measure the complexity of each layer in a finer way
than before. First, we can try to abstract from the complexity of a
layer (e.g. like in this paper, by assuming that the other layer is kept
within certain complexity bounds). Second, we can also measure
separately the interaction complexity of different agents.
4.2 Modular Interpreted Systems vs. Simple
Reactive Modules
In this section we show that simple reactive modules are (as we
already suggested) a specific (and somewhat limited) 
implementation of modular interpreted systems. First, we define our (quite
strong) notion of equivalence of representations.
DEFINITION 7. Two representations are equivalent if they 
unfold to isomorphic concurrent epistemic game structures. They are
CGS-equivalent if they unfold to the same CGS.
PROPOSITION 9. For any SRML there is a CGS-equivalent MIS.
PROOF. Consider an SRML R with k modules and n variables.
We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act =
{ 1, ..., n, ⊥1, ..., ⊥n}, and In =
Sk
i=1 Sti × Sti (the local state
spaces Sti will be defined in a moment). Let us assume without loss
of generality that ctri = {x1, ..., xr}. Also, we consider all guarded
commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥
i,ψ : ψ ;
xi := ⊥. Now, agent ai in S has the following components: Sti =
P(ctri) (i.e., local states of ai are valuations of variables controlled
by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ;
ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) =
{xi ∈ ctri | q1, ..., qk |=
W
γi,ψ
ψ}, {xi ∈ ctri | q1, ..., qk |=
W
γ⊥
i,ψ
ψ} . To define local transitions, we consider three cases. If
t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for
every action α. If t = ∅, we take any arbitrary ˆx ∈ t, and 
define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise;
oi(qi, ⊥j, t, f ) = qi \ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.
Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and 
define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \ {ˆx} otherwise;
oi(qi, ⊥j, t, f ) = qi \{xj} if xj ∈ f, and qi \{ˆx} otherwise. Finally,
Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.
The above construction shows that SRML have more compact
representation of states than MIS: ri local variables of agent i give
rise to 2ri
local states. In a way, reactive modules (both simple
and full) are two-level representations: first, the system is 
represented as a product of modules; next, each module can be seen
as a product of its variables (together with their update operations).
Note, however, that specification of updates with respect to a single
variable in an SRML may require guarded commands of total length
O(2
Pk
i=1 ri
). Thus, the representation of transitions in SRML is (in
the worst case) no more compact than in MIS, despite the two-level
structure of SRML. We observe finally that MIS are more general,
because in SRML the current actions of other agents have no 
influence on the outcome of agent i"s current action (although the
outcome can be influenced by other agents" current local states).
4.3 Model Checking Modular Interpreted 
Systems
One of our main aims was to study the complexity of symbolic
model checking ATLir in a meaningful way. Following the 
reviewers" remarks, we state our complexity results only as conjectures.
Preliminary proofs can be found in [14].
CONJECTURE 10. Model checking ATL for modular interpreted
systems is EXPTIME-complete.
CONJECTURE 11. Model checking ATLir for the class of 
modular interpreted systems is PSPACE-complete.
A summary of complexity results for model checking 
temporal and strategic logics (with and without epistemic component)
is given in the table below. The table presents completeness 
results for various models and settings of input parameters. Symbols
n, k, m stand for the number of states, agents and transitions in an
explicit model; l is the length of the formula, and nlocal is the 
number of local states in a concurrent program or modular interpreted
system. The new results, conjectured in this paper, are printed in
italics. Note that the result for model checking ATL against modular
interpreted systems is an extension of the result from [22].
m, l n, k, l nlocal, k, l
CTL P [5] P [5] PSPACE [15]
CTLK P [5, 8] P [5, 8] PSPACE [20]
ATL P [3] ΔP
3 [12, 16] EXPTIME
ATLir ΔP
2 [21, 13] ΔP
3 [13] PSPACE
If we are right, then the results for ATL and ATLir form an 
intriguing pattern. When we compare model checking agents with
perfect vs. imperfect information, the first problem appears to be
much easier against explicit models measured with the number of
transitions; next, we get the same complexity class against explicit
models measured with the number of states and agents; finally,
model checking imperfect information turns out to be easier than
model checking perfect information for modular interpreted 
systems. Why can it be so?
First, a MIS unfolds into CEGS and CGS in a different way. In
the first case, the MIS is assumed to encode the epistemic relations
explicitly (which makes it explode when we model agents with 
perfect, or almost perfect information). In the latter case, the epistemic
The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903
aspect is ignored, which gives some extra room for encoding the
transition relation more efficiently. Another crucial factor is the
number of available strategies (relative to the size of input 
parameters). The number of all strategies is exponential in the number
of global states; for uniform strategies, there are usually much less
of them but still exponentially many in general. Thus, the fact that
perfect information strategies can be synthesized incrementally has
a substantial impact on the complexity of the problem. However,
measured in terms of local states and agents, the number of all
strategies is doubly exponential, while there are only 
exponentially many uniform strategies - which settles the results in favor of
imperfect information.
