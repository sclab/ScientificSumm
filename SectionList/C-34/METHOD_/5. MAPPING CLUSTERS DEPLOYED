SENSOR NETWORKS TO H(K,U,M,V,N)
Obviously, from the description in section 3 and 4, we can know
that the clusters deployed sensor network can be mapped into a 
klevels- hierarchical hypercube model as follows:
At first, the k clusters in the sensor network can be mapped into k
different levels (or hypercubes) in the k-levels- hierarchical
hypercube model. Then, the sensor nodes in each cluster can be
encoded with the In-Cluster-Hypercube-Node-Codes, and the
sensor nodes in the k different clusters with the same 
In-ClusterHypercube-Node-Codes can be encoded with the 
Out-ClusterHypercube-Node-Codes according to the definition 5 respectively.
Consequently, the whole sensor network has been mapped into a
k-levels- hierarchical hypercube model.
6. H(K,U,M,V,N) MODEL-BASED
PAIRWISE KEY PREDISTRIBUTION
ALGORITHM FOR SENSOR NETWORKS
In order to overcome the drawbacks of polynomial-based and
polynomial pool-based key predistribution algorithms, this paper
proposed an innovative H(k,u,m,v,n) model-based key
predistribution scheme and pairwise key establishment algorithm,
which combines the advantages of polynomial-based and key
pool-based encryption schemes, and is based on the KDC and
polynomials pool-based key predistribution models.
The new H(k,u,m,v,n) model-based pairwise key establishment
algorithm includes three main steps: (1) Generation of the
polynomials pool and key predistribution, (2) Direct pairwise key
discovery, (3) Path key discovery.
6.1 Generation of Polynomials Pool and Key
Predistribution
Supposing that, the sensor network includes N nodes, and is
deployed through k different rounds. Then we can predistribute
keys for each sensor node on the basis of the H(k,u,m,v,n) model
as follows:
Step 1: Key setup server randomly generates a bivariate
polynomials pool such as the following: F={ f i
iiil n >< −121 ,...,,, (x,y),
f j
jjjinii m >< −121
,...,,,,...,2,1
(x,y) | 0 ≤ iii n 121 ... −≤≤≤ ≤ v-1, 1 ≤ i ≤ n,
1 ≤ l ≤ k; 0 ≤ jjj m 121 ... −≤≤≤ ≤ u-1 , 1 ≤ j ≤ m} with vn
*m*um-1
+[N/vn
]*n*vn-1
different t-degree bivariate polynomials over a finite
field Fq, and then assigns a unique polynomial ID to each
bivariate polynomial in F.
Step 2: In each round, key setup server assigns a unique node
ID: (i1i2…in,j1j2…jm) to each sensor node from small to big, where
0 ≤ i1,i2,…in ≤ v-1, 0 ≤ j1,j2,…jm ≤ u-1.
Step 3: key setup server assigns a unique cluster ID: l to all
the sensor nodes deployed in the same round, where 1 ≤ l ≤ k.
Step 4: key setup server predistributes m+n bivariate
polynomials { f iiil n
1
,...,,, 32 >< (i1,y),…, f n
iiil n >< −121 ,...,,, (in,y);
f jjinii m
1
,...,,,...,2,1 2
>< ( j1,y),…, f m
jjinii m >< −11
,...,,,...,2,1
( jm,y) } and the
corresponding polynomial IDs to the sensor node deployed in the
lth round and with ID (i1i2…in, j1j2…jm).
6.2 Direct Pairwise Key Discovery
If the node A(i1i2…in,j1j2…jm) in the sensor network wants to
establish pairwise key with a node B (i'1i'2…i'n,j'1j'2…j'm), then
node A can establish pairwise key with the node B trough the
following methods.
Firstly, node A computes out the distance between itself and node
B: d= d1+ d2, where d1=dh(i1i2…in, i'1i'2…i'n) and d2=dh(j1j2…jm,
j'1j'2…j'm). If d=1, then node A obtains the direct pairwise key
between itself and node B according to the following theorem 1:
Theorem 1: For any two sensor nodes A(i1i2…in,j1j2…jm) and B
(i'1i'2…i'n,j'1j'2…j'm) in the sensor network, supposing that the
56
distance between nodes A and B is d= d1+ d2, where d1=dh(i1i2…in,
i'1i'2…i'n) and d2=dh(j1j2…jm, j'1j'2…j'm). If d=1, then there exists a
direct pairwise key between nodes A and B.
Poof: Since d=1, then there is d1=1, d2=0, or d1=0, d2=1.
1) If d1=1, d2=0: From d2=0, there is nodes A, B belong to the
same cluster. Supposing that nodes A, B belong to the same
cluster l, then from d1=1 ⇒ There is only one position different
between i1i2…in and i"1i"2…i"n. Let it=i"t, when 1 ≤ t ≤ n-1, and
in ≠ i"n ⇒ f n
iiil n >< −121 ,...,,, (in,i"n)= f n
iiil n >′′′< −121 ,...,,, (i"n,in). So, there
exists a direct pairwise key f n
iiil n >< −121 ,...,,, (in,i"n) between nodes A
and B.
2) If d1=0, d2=1: From d2=1 ⇒ There is only one position
different between j1j2…jm and j"1j"2…j"m. Let jt=j"t, when 1 ≤ t ≤ 
m1, and jm ≠ j"m. Since d1=0 ⇒ i1i2…in equals to
i"1i"2…i"n ⇒ f m
jjjinii m >< −121
,...,,,,...,2,1
(jm, j"m)=
f m
jjji nii m >′′′′′′< −121
,...,,,,...,2,1
(j"m,jm). So, there exists a direct pairwise
key f m
jjjinii m >< −121
,...,,,,...,2,1
(jm, j"m) between nodes A and B.
According to theorem 1, we present the detailed description of the
direct pairwise key discovery algorithm as follows:
Step 1: Obtain the node IDs and cluster IDs of the source
node A and destination node B;
Step 2: Compute out the distance between nodes A and B: d=
d1+ d2;
Step 3: If d1=1, d2=0, then select out a common polynomial
share of nodes A and B from { f iiil n
1
,...,,, 32 >< ,..., f n
iiil n >< −121 ,...,,, } to
establish direct pairwise key;
Step 4: If d1=0, d2=1, then select out a common polynomial
share of nodes A and B from
{ f jjinii m
1
,...,,,...,2,1 2
>< ,..., f m
jjjinii m >< −121
,...,,,,...,2,1
} to establish direct
pairwise key;
Step 5: Otherwise, there exists no direct pairwise key
between nodes A and B. And then turn to the following path key
discovery process.
6.3 Path Key Discovery
If d>1, then node A can establish path key with node B according
to the following theorem 2:
Theorem 2: For any two sensor nodes A(i1i2…in,j1j2…jm) and B
(i'1i'2…i'n,j'1j'2…j'm) in the sensor network, supposing that the
distance between nodes A and B is d= d1+ d2, where d1=dh(i1i2…in,
i'1i'2…i'n) and d2=dh(j1j2…jm, j'1j'2…j'm). If d>1, then there exists a
path key between nodes A and B.
Proof: Let d1=a, d2=b, then we can think that it ≠ i't, when
1 ≤ t ≤ a; but it=i't, when t>a; and jt ≠ j't, when 1 ≤ t ≤ b; but jt=j't,
when t>b. Obviously, nodes A(i1i2…in, j1j2…jm) ,(i'1i2 i3…in,
j1j2…jm),(i'1i'2 i3…in, j1j2…jm),…,(i'1i'2…i'n, j1j2…jm) belong to the
same cluster. So, according to the supposing condition of The
nodes in the same cluster form a connected graph, there is a
route among those nodes. In addition, in those nodes, the distance
between any two neighboring nodes is 1, so from theorem 1, it is
easy to know that there exists direct pairwise key between any
two neighboring nodes among those nodes.
For nodes (i'1i'2…i'n,j1j2…jm), (i'1i'2…i'n,j'1 j2 j3…jm),
(i'1i'2…i'n,j'1j'2 j3…jm-1 jm),…, (i'1i'2…i'n,j'1j'2…j'm-1jm), since they
have the same Out-Cluster-Hypercube-Node-Codes with the node
B(i'1i'2…i'n,j'1j'2…j'm), so nodes (i'1i'2…i'n,j1j2…jm), (i'1i'2…i'n,j'1 j2
j3…jm), (i'1i'2…i'n,j'1j'2 j3…jm-1 jm),…, (i'1i'2…i'n,j'1j'2…j'm-1 jm) and
node B belong to a same logical hypercube. Obviously, from the
supposing condition of The whole sensor network forms a
connected graph, there is a route among those nodes. In addition,
in those nodes, the distance between any two neighboring nodes is
1, so from theorem 1, it is easy to know that there exists direct
pairwise key between any two neighboring nodes among those
nodes.
So, it is obvious that there exists a path key between nodes A
and B.
According to theorem 2, we present the detailed description of the
path key discovery algorithm as follows:
Step 1: Compute out the intermediate nodes (i'1i2
i3…in,j1j2…jm), (i'1i'2 i3…in,j1j2…jm),…,(i'1i'2…i'n, j1j2…jm) and
(i'1i'2…i'n,j1'j2 j3…jm), (i'1i'2…i'n,j'1j'2 j3…j'm-1
jm),…,(i'1i'2…i'n,j'1j'2…j'm-1 jm) from the source node
A(i1i2…in,j1j2…jm) and the destination node B (i'1i'2…i'n,j'1j'2…j'm).
Step 2: In those nodes series A(i1i2…in,j1j2…jm), (i'1i2
i3…in,j1j2…jm), (i'1i'2 i3…in,j1j2…jm),…,(i'1i'2…i'n,j1j2…jm) and
(i'1i'2…i'n,j1'j2 j3…jm), (i'1i'2…i'n,j'1j'2 j3…j'm-1 jm),…, (i'1i'2…i'n,
j'1j'2…j'm-1 jm), B (i'1i'2…i'n,j'1j'2…j'm), the neighboring nodes select
their common polynomial share to establish direct pairwise key.
From theorem 2, it is easy to know that any source node A
can compute out a key path P to the destination node B according
to the above algorithm, when there are no compromised nodes in
the sensor network. Once the key path P is computed out, then
node A can send messages to B along the path P to establish
indirect pairwise key with node B. Fig.2 presents a example of
key path establishment.
Figure.2 Key path establishment example.
For example: In the above Figure.2, node A((012),(1234)) can
establish pairwise key with node B((121),(2334)) through the
following key path: A((012),(1234)) → C((112),(1234)) →
D((122),(1234)) → E((121),(1234)) → F((121),(2234)) →
B((121),(2334)), where node F shall route through nodes G, H, I,
J to establish direct pairwise key with node B.
57
According to the properties of H(k,u,m,v,n) model, we can prove
that the following theorem by combing the proof of theorem 2:
Theorem 3: Supposing that there exist no compromised nodes in
the sensor network, and the distance between node A and B, then
there exists a shortest key path with k distance between node A
and B logically. That is to say, node A can establish indirect
pairwise key with node B through t-1 intermediate nodes.
Proof: Supposing that the distance between node A(i1i2…in,
j1j2…jm) and B (i'1i'2…i'n, j'1j'2…j'm) is d=d1+ d2, where
d1=dh(i1i2…in, i'1i'2…i'n), d2=dh(j1j2…jm, j'1j'2…j'm). Since d=t,
according to the construction properties of H(k,u,m,v,n), it is easy
to know that there exist t-1 intermediate nodes I1,…,It-1, in the
logical space H(k,u,m,v,n), which satisfy that the distance
between any two neighboring nodes in the nodes series A, 
I1,…,It1, B equals to 1. So according to the theorem 1, we can know that
nodes A, I1,…,It-1, B form a correct key path between node A and
B. If any two neighboring nodes in the nodes series A, I1,…,It-1, B
can communicate directly, then node A can establish indirect
pairwise key with node B through those t-1 intermediate nodes.
6.4 Dynamic Path Key Discovery
The path key discovery algorithm proposed in the above section
can establish a key path correctly, only when there exist no
compromised nodes in the whole sensor network, since the key
path is computed out beforehand. And the proposed algorithm
cannot find an alternative key path when there exist some
compromised nodes or some intermediate nodes not in the
communication radius, even that there exists other alternative key
paths in the sensor network. From the following example we can
know that there are many parallel paths in the H(k,u,m,v,n) model
for any two given source and destination nodes, since the
H(k,u,m,v,n) model is high fault-tolerant[9,10]
.
Figure.3 Alternative key path establishment example.
For example: Considering the key path establishment example
given in the above section based on Figure.2:
A((012),(1234)) → C((112),(1234)) → D((122),(1234)) →
E((121),(1234)) → F((121),(2234)) → B((121),(2334)),
supposing that node F((121),(2234)) has compromised, then from
Figure.3, we can know that there exists another alternative key
path as A((012),(1234)) → C((112),(1234)) → D((122),(1234))
→E((121),(1234)) → M((121),(1334)) → B((121),(2334)), which
can be used to establish the indirect pairwise key between node A
and B, where node E shall route through nodes D and K to
establish direct pairwise key with node M, and node M shall route
through nodes N, O, G, H, I, J to establish direct pairwise key
with node B.
Since the sensors are source limited, so they are easy to die or out
of the communication radius, therefore the algorithm proposed in
the above section cannot guarantee to establish correct key path
efficiently. In this section, we will propose a dynamic path key
discovery algorithm as follows, which can improve the
probability of key path effectively:
Algorithm I: Dynamic key path establishment algorithm based on
H(k,u,m,v,n) model for cluster deployed sensor networks.
Input: Sub-sensor network H(k,u,m,v,n), which has some
compromised /fault sensors and fault links, And two reachable
nodes A(a1…an,a"1…a"m) and B(b1…bn,b"1…b"m) in H(k,u,m,v,n),
where a"t ≠ b"t, t∈[1,s], a"t=b"t, t >s.
Output: A correct key path from node A to B in H(k,u,m,v,n).
Step 1: Obtain the code strings of node A and B: A ←
(a1…an,a"1…a"m), B ← (b1…bn,b"1…b"m), where aj, bj [0,∈ u-1],
a"j, b"j [0,∈ v-1].
Step 2: If a"1…a"m = b"1…b"m, then node A can find a route
to B according to the routing algorithms of hypercube [9-10].
Step 3: Otherwise, node A can find a route to C(b1…bn,
a"1…a"m) according to the Algorithm I or Algorithm II. Then let
I0=C(b1…bn,a"1…a"m), I1=(b1…bn,b"1 a"2…a"m),…,
Is=B(b1…bn,b"1 b"2…b"s a"s+1…a"m), and each node It in the above
nodes series find a route to its neighboring node It+1 on the basis
of the location information (Detailed routing algorithms based on
location information can see the references[11-14]).
Step 4: Algorithm exits. If such kind of a correct key path
exists, then through which node A can establish an indirect
pairwise key with node B. Otherwise, node A fails to establish an
indirect pairwise key with node B. And node A will tries again to
establish an indirect pairwise key with node B some time later.
