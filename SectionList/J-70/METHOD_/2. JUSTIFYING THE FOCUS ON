NONMANIPULABLE MECHANISMS
Before we define the computational problem of automated
mechanism design, we should justify our focus on 
nonmanipulable mechanisms. After all, it is not immediately 
obvious that there are no manipulable mechanisms that, even
when agents report their types strategically and hence 
sometimes untruthfully, still reach better outcomes (according to
whatever objective we use) than any nonmanipulable 
mechanism. This does, however, turn out to be the case: given
any mechanism, we can construct a nonmanipulable 
mechanism whose performance is identical, as follows. We build
an interface layer between the agents and the original 
mechanism. The agents report their preferences (or types) to
the interface layer; subsequently, the interface layer inputs
into the original mechanism the types that the agents would
have strategically reported to the original mechanism, if their
types were as declared to the interface layer. The resulting
outcome is the outcome of the new mechanism. Since the
interface layer acts strategically on each agent"s behalf,
there is never an incentive to report falsely to the interface
layer; and hence, the types reported by the interface layer
are the strategic types that would have been reported 
without the interface layer, so the results are exactly as they
would have been with the original mechanism. This 
argument is known in the mechanism design literature as the 
revelation principle [16]. (There are computational difficulties
with applying the revelation principle in large combinatorial
outcome and type spaces [7, 22]. However, because here we
focus on flatly represented outcome and type spaces, this is
not a concern here.) Given this, we can focus on truthful
mechanisms in the rest of the paper.